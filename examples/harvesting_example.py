#!/usr/bin/env python3
"""
Quantum Field Harvesting Contextual Fraction Analysis

This script analyzes the contextual fraction for states generated by the 
twoqutrits_SUtwo function across different parameter regimes and lambda values. 
It studies how quantum contextuality varies with the coupling strength in 
quantum field harvesting scenarios.

The analysis focuses on 5 specific parameter combinations where d, a >> sigma,
testing all available Q-functions to examine the emergence of contextuality.
"""

import sys
import os
import numpy as np

# Add src to path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))

from qft.detectors import twoqutrits_SUtwo, QregDelta, QregHeavsde, Qmagic
from optimization.lin_prog import contextual_fraction


def analyze_rho_state(sigma, d, a, lam, state_name):
    """
    Analyze the contextual fraction for a given rho function state with lambda parameter.
    """
    print(f"\n{'='*80}")
    print(f"Analyzing {state_name}: sigma={sigma}, d={d}, a={a}, lambda={lam}")
    print(f"{'='*80}")
    
    # Test all Q-functions for this state
    q_functions = [
        (QregDelta, "QregDelta"),
        (QregHeavsde, "QregHeavsde"),
        (Qmagic, "Qmagic")
    ]
    
    for qfunc, qfunc_name in q_functions:
        print(f"\n--- Using Q-function: {qfunc_name} ---")
        
        # Create the density matrix using twoqutrits_SUtwo function directly
        # Note: This function needs Om parameter, so we'll estimate it from sigma
        Om = 1.0 / sigma  # Rough estimate based on field theory scaling
        rho_matrix = twoqutrits_SUtwo(Om, sigma, d, a, qfunc, lam)
        
        # Check density matrix properties
        eigenvalues = np.linalg.eigvals(rho_matrix)
        min_eigenvalue = np.min(eigenvalues)
        
        if min_eigenvalue < 0:
            print(f"   Warning: Negative eigenvalue {min_eigenvalue:.6f} detected")
        
        # Calculate contextual fraction
        try:
            result = contextual_fraction(rho_matrix)
            if result['success']:
                cf = result['b']
                print(f"   Contextual Fraction: {cf:.6f}")
            else:
                print(f"   Error: Optimization failed - {result['result'].message}")
        except Exception as e:
            print(f"   Error calculating contextual fraction: {e}")
            
        # Check density matrix properties
        trace = np.trace(rho_matrix)
        eigenvals = np.linalg.eigvals(rho_matrix)
        is_hermitian = np.allclose(rho_matrix, rho_matrix.T.conj())
        
        print(f"   Trace: {trace:.6f}")
        print(f"   Is Hermitian: {is_hermitian}")
        print(f"   Min eigenvalue: {np.min(eigenvals):.6f}")
        print(f"   Max eigenvalue: {np.max(eigenvals):.6f}")
        print(f"   Matrix shape: {rho_matrix.shape}")


def main():
    """
    Example analysis showing how contextual fraction varies with lambda parameter
    for the rho function across different parameter regimes.
    """
    print("Contextual Fraction Analysis for Rho Function States")
    print("==================================================")
    print("This analysis studies how the contextual fraction changes with lambda")
    print("parameter for various states generated by the rho function.")
    print("The rho function generates quantum field harvesting states with")
    print("varying degrees of quantum contextuality based on the coupling strength.")
    
    # Define 5 specific example cases where d, a >> sigma
    examples = [
        # (sigma, d, a, lambda, name)
        (0.1, 10.0, 10.0, 1.0, "Example 1: Small sigma, large d & a"),
        (0.05, 20.0, 15.0, 0.5, "Example 2: Very small sigma, very large d & a"),
        (0.2, 8.0, 12.0, 2.0, "Example 3: Moderate sigma, large d & a"),
        (0.01, 50.0, 30.0, 0.1, "Example 4: Tiny sigma, huge d & a"),
        (0.15, 15.0, 8.0, 1.5, "Example 5: Small sigma, asymmetric large d & a")
    ]
    
    # Analyze each example
    for sigma, d, a, lam, name in examples:
        analyze_rho_state(sigma, d, a, lam, name)
    
    print(f"\n{'='*80}")
    print("Analysis Complete")
    print(f"{'='*80}")
    print("Summary: This analysis demonstrates contextual fraction behavior")
    print("for rho function states across different lambda parameter values.")
    print("The rho function generates quantum field harvesting states with")
    print("varying degrees of quantum contextuality based on the coupling strength.")
    print("\nKey observations:")
    print("- Each state is tested with all three Q-functions (QregDelta, QregHeavsde, Qmagic)")
    print("- Lambda parameter controls the coupling strength in quantum field harvesting")
    print("- Parameter regime: d, a >> sigma ensures proper field theory limit")
    print("- Contextual fraction quantifies the degree of quantum contextuality")


if __name__ == "__main__":
    main()
