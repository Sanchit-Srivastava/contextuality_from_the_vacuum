#!/usr/bin/env python3
"""
Contextual Fraction Analysis for Quantum Field Harvesting States

This script analyzes the contextual fraction for states generated by the rho 
function in detectors.py. It explores how quantum contextuality varies with 
the perturbative coupling strength (lambda) across different Q-functions.

Parameters are chosen such that d, a >> sigma (field theory limit) and 
lambda is small (perturbative regime).
"""

import sys
import os
import numpy as np

# Add src to path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))

from qft.detectors import rho, QregDelta, QregHeavsde, Qmagic
from optimization.lin_prog import contextual_fraction


def analyze_state(sigma, d, a, lam, qfunc, qfunc_name, example_name):
    """
    Analyze a single quantum state for contextual fraction.
    
    Args:
        sigma, d, a, lam: Physical parameters
        qfunc: Q-function (QregDelta, QregHeavsde, or Qmagic)
        qfunc_name: Name of Q-function for display
        example_name: Name of parameter set for display
    
    Returns:
        dict: Analysis results
    """
    try:
        # Generate the density matrix
        rho_matrix = rho(sigma, d, a, qfunc, lam)
        
        # Check matrix properties
        trace = np.trace(rho_matrix)
        eigenvals = np.linalg.eigvals(rho_matrix)
        min_eigenval = np.min(np.real(eigenvals))
        is_hermitian = np.allclose(rho_matrix, rho_matrix.T.conj())
        is_valid = (abs(trace - 1.0) < 1e-10 and 
                   is_hermitian and 
                   min_eigenval >= -1e-10)
        
        # Calculate contextual fraction
        cf_result = contextual_fraction(rho_matrix)
        
        # Scale by lambda^2 to get intrinsic perturbative contribution
        cf_scaled = None
        if cf_result['success'] and cf_result.get('b', None) is not None:
            cf_scaled = cf_result['b'] / (lam**2) if lam > 0 else None
        
        return {
            'success': True,
            'trace': trace,
            'min_eigenval': min_eigenval,
            'is_valid': is_valid,
            'cf_success': cf_result['success'],
            'contextual_fraction': cf_result.get('b', None) if cf_result['success'] else None,
            'cf_scaled': cf_scaled,
            'cf_error': None if cf_result['success'] else str(cf_result.get('result', 'Unknown error'))
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': str(e)
        }


def run_lambda_sweep(sigma, d, a, example_name):
    """
    Run analysis across different lambda values for a given parameter set.
    """
    print(f"\n{'='*80}")
    print(f"Example: {example_name}")
    print(f"Parameters: σ={sigma:.3f}, d={d:.1f}, a={a:.1f}")
    print(f"Ratios: d/σ={d/sigma:.1f}, a/σ={a/sigma:.1f}")
    print(f"{'='*80}")
    
    # Lambda values for sweep (small perturbative values)
    lambda_values = [1e-5, 5e-5, 1e-4, 5e-4, 1e-3, 5e-3, 1e-2]
    
    # Q-functions to test
    qfunctions = [
        (QregDelta, "QregDelta"),
        (QregHeavsde, "QregHeavsde"), 
        (Qmagic, "Qmagic")
    ]
    
    results = {}
    
    for qfunc, qfunc_name in qfunctions:
        print(f"\n--- Q-function: {qfunc_name} ---")
        print(f"{'λ':>8} {'CF':>12} {'CF/λ²':>12} {'Valid':>8} {'Status':>15}")
        print("-" * 65)
        
        qfunc_results = []
        
        for lam in lambda_values:
            result = analyze_state(sigma, d, a, lam, qfunc, qfunc_name, 
                                 example_name)
            
            if result['success']:
                cf_val = result['contextual_fraction']
                cf_scaled = result['cf_scaled']
                valid = result['is_valid']
                
                if result['cf_success'] and cf_val is not None:
                    cf_str = f"{cf_val:.8f}"
                    cf_scaled_str = f"{cf_scaled:.2f}" if cf_scaled is not None else "N/A"
                    status = "SUCCESS"
                else:
                    cf_str = "FAILED"
                    cf_scaled_str = "N/A"
                    status = "CF_ERROR"
                    
                print(f"{lam:>8.0e} {cf_str:>12} {cf_scaled_str:>12} {str(valid):>8} {status:>15}")
                
            else:
                print(f"{lam:>8.0e} {'ERROR':>12} {'N/A':>12} {'N/A':>8} {'MATRIX_ERROR':>15}")
            
            qfunc_results.append({
                'lambda': lam,
                'result': result
            })
        
        results[qfunc_name] = qfunc_results
    
    return results


def display_summary(all_results):
    """Display summary of all results."""
    print(f"\n{'='*80}")
    print("SUMMARY ANALYSIS")
    print(f"{'='*80}")
    
    for example_name, example_results in all_results.items():
        print(f"\n{example_name}:")
        
        for qfunc_name, qfunc_results in example_results.items():
            # Find highest successful contextual fraction
            max_cf = 0.0
            max_cf_scaled = 0.0
            best_lambda = None
            
            successful_results = [r for r in qfunc_results 
                                if r['result']['success'] and 
                                   r['result']['cf_success'] and
                                   r['result']['contextual_fraction'] is not None]
            
            if successful_results:
                for r in successful_results:
                    cf = r['result']['contextual_fraction']
                    cf_scaled = r['result']['cf_scaled']
                    if cf > max_cf:
                        max_cf = cf
                        max_cf_scaled = cf_scaled if cf_scaled is not None else 0.0
                        best_lambda = r['lambda']
                
                print(f"  {qfunc_name:12}: Max CF = {max_cf:.8f} (CF/λ² = {max_cf_scaled:.2f}) at λ = {best_lambda:.0e}")
            else:
                print(f"  {qfunc_name:12}: No successful results")


def main():
    """
    Main analysis function - tests 5-10 parameter sets with lambda sweeps.
    """
    print("Quantum Field Harvesting - Contextual Fraction vs Lambda Analysis")
    print("================================================================")
    print("Testing how contextual fraction varies with perturbative coupling")
    print("strength (lambda) for different Q-functions and parameter regimes.")
    print("Condition: d, a >> sigma (field theory limit)")
    
    # Define parameter sets where d, a >> sigma (but numerically stable)
    parameter_sets = [
        {
            'sigma': 1.0,
            'd': 10.0,
            'a': 10.0,
            'name': 'Balanced regime: σ=1, d=a=10'
        },
        {
            'sigma': 0.5,
            'd': 8.0,
            'a': 12.0,
            'name': 'Moderate ratios: σ=0.5, d=8, a=12'
        },
        {
            'sigma': 2.0,
            'd': 15.0,
            'a': 15.0,
            'name': 'Large σ: σ=2, d=a=15'
        },
        {
            'sigma': 0.8,
            'd': 6.0,
            'a': 8.0,
            'name': 'Conservative ratios: σ=0.8, d=6, a=8'
        },
        {
            'sigma': 1.5,
            'd': 12.0,
            'a': 10.0,
            'name': 'Asymmetric: σ=1.5, d=12, a=10'
        },
        {
            'sigma': 0.3,
            'd': 5.0,
            'a': 7.0,
            'name': 'Small σ: σ=0.3, d=5, a=7'
        }
    ]
    
    # Run analysis for each parameter set
    all_results = {}
    
    for params in parameter_sets:
        results = run_lambda_sweep(
            params['sigma'], 
            params['d'], 
            params['a'], 
            params['name']
        )
        all_results[params['name']] = results
    
    # Display summary
    display_summary(all_results)
    
    print(f"\n{'='*80}")
    print("ANALYSIS COMPLETE")
    print(f"{'='*80}")


if __name__ == "__main__":
    main()
