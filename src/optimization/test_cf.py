# Compute contextual fraction (CF) for a single-qutrit stabilizer measurement scenario
# for the state |H3> = (|0> + |1>)/sqrt(2), using Abramsky–Barbosa–Mansfield LP.
#
# Scenario: measurements are the 4 cyclic commuting families generated by
#   G ∈ {Z, X, XZ, XZ^2}. Each context is the pair {G, G^2}.
# Local outcomes are labels k∈{0,1,2} for eigenvalues {1, ω, ω^2} of G.
# For a joint measurement {G, G^2}, only assignments (k, 2k mod 3) are physically possible.
# The empirical model v_e is built from the projective probabilities of |H3> in each eigenbasis of G.
#
# We then build the incidence matrix M between global assignments (outcomes for all 8 measurements)
# and local assignments (for each of 4 contexts), and solve the LP:
#   maximize 1^T b  s.t. M b <= v_e,  b >= 0
# The noncontextual fraction NCF = 1^T b*, and CF = 1 - NCF.

import numpy as np
from math import isclose
from itertools import product
from scipy.optimize import linprog

np.set_printoptions(suppress=True, precision=6)

d = 3
omega = np.exp(2j * np.pi / d)

# Computational basis |0>, |1>, |2>
e0 = np.array([1,0,0], dtype=complex)
e1 = np.array([0,1,0], dtype=complex)
e2 = np.array([0,0,1], dtype=complex)
I = np.eye(3, dtype=complex)

# Qutrit Pauli operators (Heisenberg–Weyl)
# Z|j> = ω^j |j>,  X|j> = |j+1 mod 3>
Z = np.diag([1, omega, omega**2])
X = np.roll(np.eye(3, dtype=complex), 1, axis=1)  # shift columns to the right

def unitary_eig_projectors(U):
    # Get eigenvalues, eigenvectors; map eigenvalues close to {1, ω, ω^2} to labels 0,1,2
    vals, vecs = np.linalg.eig(U)
    # Normalize eigenvectors to unit norm with deterministic phase
    for k in range(vecs.shape[1]):
        # fix global phase: make first nonzero component real and positive
        v = vecs[:, k]
        idx = np.argmax(np.abs(v))
        phase = np.exp(-1j * np.angle(v[idx]))
        vecs[:, k] = v * phase / np.linalg.norm(v)
    labels = []
    for lam in vals:
        # Map eigenvalue to label by nearest of {1, ω, ω**2}
        candidates = np.array([1, omega, omega**2])
        dists = np.abs(candidates - lam)
        lbl = int(np.argmin(dists))
        labels.append(lbl)
    # Sort eigenvectors by label 0,1,2 for stable ordering
    order = np.argsort(labels)
    labels_sorted = [labels[i] for i in order]
    vecs_sorted = vecs[:, order]
    # Build projectors Π_k = |φ_k><φ_k| in that order
    projectors = [np.outer(vecs_sorted[:,k], np.conj(vecs_sorted[:,k])) for k in range(3)]
    return labels_sorted, projectors

# Define the four generators G ∈ {Z, X, XZ, XZ^2}
G_list = [Z, X, X @ Z, X @ (Z @ Z)]  # XZ, XZ^2
# Ensure they are unitary with nondegenerate spectrum
# Prepare contexts as pairs (G, G^2) and their projectors (shared eigenbasis)
contexts = []
for G in G_list:
    # Stabilizer convention ignores global phases; G and G^2 share eigenbasis
    _, Pk = unitary_eig_projectors(G)
    contexts.append({
        "G": G,
        "G2": G @ G,
        "projectors": Pk  # list of Π_k, k=0,1,2, eigenbasis shared by G and G^2
    })

# State |H3> = (|0> + |1>)/sqrt(2)
psi = (e0 + e1) / np.sqrt(2)
rho = np.outer(psi, np.conj(psi))

# Build empirical model v_e over all contexts and local assignments s=(o_G, o_G2) in {0,1,2}^2
# Flatten order: for each context in order, list 9 assignments in lexicographic order (o_g, o_g2).
ve = []
row_index_info = []  # to decode rows later if needed
for ci, ctx in enumerate(contexts):
    # Probabilities p_k = Tr(Π_k rho)
    p = np.array([np.real_if_close(np.trace(P @ rho)) for P in ctx["projectors"]], dtype=float)
    # Numerical rounding safety
    p = np.clip(p, 0, 1)
    p = p / p.sum()
    # Fill 9 entries
    for o1 in range(3):
        for o2 in range(3):
            if o2 % 3 == (2 * o1) % 3:
                prob = float(p[o1])
            else:
                prob = 0.0
            ve.append(prob)
            row_index_info.append((ci, o1, o2))
ve = np.array(ve)

m = len(ve)  # number of local events
# Measurements set: the 8 observables [Z,Z^2,X,X^2,XZ,(XZ)^2,XZ^2,(XZ^2)^2]
meas_ops = []
for G in G_list:
    meas_ops.append(G)
    meas_ops.append(G @ G)
num_meas = len(meas_ops)  # 8

# Global assignments g: outcomes {0,1,2} for each of the 8 measurements => 3^8 assignments
num_globals = 3 ** num_meas

# Incidence matrix M: shape (m, num_globals)
# M[row, g] = 1 iff g restricted to context equals that local assignment (o1, o2)
# To keep memory reasonable, we'll build M as a sparse-like structure then dense float array
M = np.zeros((m, num_globals), dtype=float)

# Map context index to the pair of measurement indices it refers to.
# Context i corresponds to measurements at indices (2*i, 2*i+1): (G, G^2)
context_to_meas_idx = [(2*i, 2*i + 1) for i in range(len(contexts))]

# Helper: decode base-3 representation
def ternary_digits(n, width):
    digs = []
    for _ in range(width):
        digs.append(n % 3)
        n //= 3
    return digs[::-1]

for g_idx in range(num_globals):
    outcomes = ternary_digits(g_idx, num_meas)  # list length 8 with values 0..2
    # Fill rows
    for r, (ci, o1, o2) in enumerate(row_index_info):
        mi1, mi2 = context_to_meas_idx[ci]
        if outcomes[mi1] == o1 and outcomes[mi2] == o2:
            M[r, g_idx] = 1.0

# Solve LP: maximize 1^T b  s.t. M b <= ve,  b >= 0
c = -np.ones(num_globals)  # linprog minimizes, so negate
A_ub = M
b_ub = ve
bounds = [(0, None)] * num_globals

res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method="highs", options={"presolve": True})

if not res.success:
    print("LP failed:", res.message)
else:
    NCF = -res.fun  # because we minimized -1^T b
    CF = 1.0 - NCF
    print("Number of contexts (size-2):", len(contexts))
    print("Rows (local events):", m, "  Columns (global assignments):", num_globals)
    print("Noncontextual fraction (NCF):", float(NCF))
    print("Contextual fraction (CF):", float(CF))

    # Optionally, compute a dual solution giving a witnessing inequality a·ve - R = CF * (k(a)-R)
    # We'll derive a tight inequality by solving the dual directly via HiGHS, if available.
    # Dual of: max 1^T b s.t. M b <= ve, b >= 0
    # is: min ve^T y  s.t. M^T y >= 1,  y >= 0
    # We'll solve it to get y*, which corresponds to coefficients over local events.
    cd = np.ones(m)  # minimize ve^T y
    # Convert to linprog standard: minimize c^T y s.t. A_ub y <= b_ub
    # We need M^T y >= 1  <=>  -M^T y <= -1
    Adual = -M.T
    bdual = -np.ones(num_globals)
    bounds_y = [(0, None)] * m
    res_dual = linprog(cd, A_ub=Adual, b_ub=bdual, bounds=bounds_y, method="highs", options={"presolve": True})
    if res_dual.success:
        y = res_dual.x
        # The inequality coefficients are 'a = y', with bound R = max_{d∈NC} a·(M d)
        # For tightness, R equals the max of a over deterministic models, i.e., max column sum of rows selected by y.
        # But we can compute the noncontextual bound as max over g of (M[:,g]·y).
        noncontextual_bound = float((M.T @ y).max())
        quantum_value = float(ve @ y)
        # Normalized violation equals (quantum_value - R) / (k(a) - R), but here k(a)=sum over contexts max over assignments a[hC,s].
        # For simplicity, report 'a' sparse support and values.
        print("\nWitness inequality (dual solution):")
        print("  Noncontextual bound R =", noncontextual_bound)
        print("  Value on our model a·v_e =", quantum_value)
        # Show top-8 largest coefficients with their (context, o1, o2)
        idx_sorted = np.argsort(-y)
        print("  Top 8 coefficients (context, o1, o2, coeff):")
        for k in idx_sorted[:8]:
            ci,o1,o2 = row_index_info[k]
            print(f"   C{ci}:({o1},{o2}) -> {y[k]:.6f}")





############
def projector(A: np.ndarray, r_a: int) -> np.ndarray:
  """
  Construct the normalized spectral projector associated with outcome r_a
  for the operator defined by vector A (arithmetic modulo 3).
  """
  r = int(r_a) % 3
  A_vec = np.asarray(A) % 3

  # Initialize with correct shape and dtype
  P = np.zeros_like(operators.pauli(0 * A_vec), dtype=complex)

  for j in range(3):
    phase = w ** (-(j * r))
    op = operators.pauli((j * A_vec) % 3)
    P += phase * op

  return P / 3